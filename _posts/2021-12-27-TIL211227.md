---
title: 12.27 MON 인증보안기초1
---

# HTTPS

HTTPS: HTTP + Secure

- 인증서(Certificate)
  
  - 데이터 제공자 신원 보장
  
  - 도메인 종속

- CA
  
  - Certificate Authority
  
  - 공인인증서 발급 기관

- 비대칭 키 암호화
  
  - 키 A로 암호화 -> 키 B로 복호화 가능

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-11-25-43-image.png)

통신초창기에서만 사용하기위해 만듬

## Hashing

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-12-13-21-image.png)

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-12-15-33-image.png)

암호화 예제(알파벳순서 +2)

어떠한 문자열에 '임의의 연산'을 적용하여 다른 문자열로 변환하는 것

1. 모든 값에 대해 해시 값을 계산하는데 오래 걸리지 않아야 한다.

2. 최대한 해시 값을 피해야 하며, 모든 값은 고유한 해시 값을 가진다.

3. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 한다.

대표적으로 (SHA1) 알고리즘이 있다.

### Salt

암호화해야 하는 값에 어떤 '별도의 값'을 추가하여 결과를 변형하는 것

1. 암호화만 해놓는다면 해시된 결과가 늘 동일
   
   해시된 값과 원래 값을 테이블(레인보우 테이블)로 만들어서 decoding 해버리는 경우도 생긴다.

2. 원본값에 임의로 약속된 '별도의 문자열'을 추가하여 해시를 진행한다면 기존 해시값과 전혀 다른 해시값이 반환되어 알고리즘이 노출되더라도 원본값을 보호할 수 있도록 하는 안전 장치

3. 기존 : (암호화 하려는 값) => (hash값)
   Salt 사용 : (암호화 하려는 값) + (Salt 용 값) => (hash 값)

### Salt 사용 시 주의점

1. Salt는 유저와 패스워드 별로 유일한 값을 가져야 한다.

2. 사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 새로운 임의의 Salt를 사용하여 해싱해야 한다.

3. Salt는 절대 재사용하지 말아야 한다.

4. Salt는 DB의 유저 테이블에 같이 저장되어야 한다.

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-12-24-28-image.png)

## Cookie

쿠키는 서버에서 클라이언트에 데이터를 저장하는 방법의 하나입니다.

그러므로 서버가 원한다면 서버는 클라이언트에서 쿠키를 이용하여 데이터를 가져올 수 있습니다.

그러므로 쿠키를 이용하는 것은 **단순히 서버에서 클라이언트에 쿠키를 전송하는 것만 의미하지 않고 클라이언트에서 서버로 쿠키를 전송하는 것도 포함됩니다.**

이런 쿠키에는 다음과 같은 특징이 있습니다.

### 서버가 클라이언트에 데이터를 저장할 수 있습니다.

앞서 언급한 것처럼 서버는 쿠키를 이용하여 데이터를 저장하고 원할 때 이 데이터를 다시 불러와 사용할 수 있습니다.
하지만 **데이터를 저장한 이후 아무 때나 데이터를 가져올 수 없습니다. 데이터를 저장한 이후 특정 조건들이 만족하는 경우에만 다시 가져올 수 있습니다.**

이런 조건들은 **쿠키 옵션**으로 표현할 수 있습니다. 아래에서는 주로 사용되는 쿠키 옵션을 설명합니다.

### 1. Domain

도메인이라는 것은 여러분들이 흔하게 보실 수 있는 `www.google.com`과 같은 서버에 접속할 수 있는 이름입니다.
쿠키 옵션에서 도메인은 포트 및 서브 도메인 정보, 세부 경로를 포함하지 않습니다.

여기서 서브 도메인이란 `www` 같은 도메인 앞에 추가로 작성되는 부분을 말합니다.

따라서 요청해야 할 URL이 `http://www.localhost.com:3000/users/login` 이라 하면

여기에서 Domain은 `localhost.com`이 됩니다.

만약 쿠키 옵션에서 도메인 정보가 존재한다면 클라이언트에서는 쿠키의 도메인 옵션과 서버의 도메인이 일치해야만 쿠키를 전송할 수 있습니다.

### 2. Path

세부 경로는 서버가 라우팅할 때 사용하는 경로입니다.
만약 요청해야 하는 URL이 `http://www.localhost.com:3000/users/login` 인 경우라면 여기에서 Path, 세부 경로는 `/users/login`이 됩니다.

명시하지 않으면 기본으로 `/` 으로 설정되어 있습니다.

Path 옵션의 특징은 설정된 path를 전부 만족하는 경우 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있습니다.
즉 Path가 `/users`로 설정되어 있고, 요청하는 세부 경로가 `/users/login` 인 경우라면 쿠키 전송이 가능합니다.

하지만 `/user/login`으로 전송되는 요청은 Path 옵션을 만족하지 못하기 때문에 서버로 쿠키를 전송할 수 없습니다.

### 3. MaxAge or Expires

쿠키가 유효한 기간을 정하는 옵션입니다.

MaxAge는 앞으로 몇 초 동안 쿠키가 유효한지 설정하는 옵션입니다.

Expires 은 MaxAge와 비슷합니다. 다만 언제까지 유효한지 `Date`를 지정합니다.
이때 클라이언트의 시간을 기준으로 합니다.

이후 지정된 시간, 날짜를 초과하게 되면 쿠키는 자동으로 파괴됩니다.

하지만 두 옵션이 모두 지정되지 않는 경우에는 브라우저의 탭을 닫아야만 쿠키가 제거될 수 있습니다.

### 4. Secure

쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부를 결정합니다.
만약 해당 옵션이 `true`로 설정된 경우, 'HTTPS' 프로토콜을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있습니다.

### 5. HttpOnly

자바스크립트에서 브라우저의 쿠키에 접근 여부를 결정합니다.
만약 해당 옵션이 `true`로 설정된 경우, 자바스크립트에서는 쿠키에 접근이 불가합니다.

명시되지 않는 경우 기본으로 `false`로 지정되어 있습니다.
만약 이 옵션이 `false`인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 'XSS' 공격에 취약합니다.

### 6. SameSite

Cross-Origin 요청을 받은 경우 요청에서 사용한 메소드와 해당 옵션의 조합으로 서버의 쿠키 전송 여부를 결정하게 됩니다.
사용 가능한 옵션은 다음과 같습니다.

- Lax :Cross-Origin 요청이면 'GET' 메소드에 대해서만 쿠키를 전송할 수 있습니다.

- Strict : Cross-Origin이 아닌 `same-site` 인 경우에만 쿠키를 전송 할 수 있습니다.

- None: 항상 쿠키를 보내줄 수 있습니다. 다만 쿠키 옵션 중 `Secure` 옵션이 필요합니다.
  
  이때 'same-site'는 요청을 보낸 Origin과 서버의 도메인이 같은 경우를 말합니다.

이러한 옵션들을 지정한 다음 서버에서 클라이언트로 쿠키를 처음 전송하게 된다면 헤더에 `Set-Cookie`라는 프로퍼티에 쿠키를 담아 쿠키를 전송하게 됩니다.

이후 클라이언트 혹은 서버에서 쿠키를 전송해야 한다면 클라이언트는 헤더에 `Cookie`라는 프로퍼티에 쿠키를 담아 서버에 쿠키를 전송하게 됩니다.

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-13-02-10-image.png)

## 쿠키를 이용한 상태 유지

이러한 쿠키의 특성을 이용하여 서버는 클라이언트에 인증정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 같이 전송하여 Stateless 한 인터넷 연결을 Stateful 하게 유지할 수 있습니다.

**하지만 기본적으로는 쿠키는 오랜 시간 동안 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있기 때문에 쿠키에 민감한 정보를 담는 것은 위험합니다.**

이런 인증정보를 탈취하여 서버에 요청을 보낸다면 서버는 누가 요청을 보낸 건지 상관하지 않고 인증된 유저의 요청으로 취급하기 때문에, 개인 유저 정보 같은 민감한 정보에 접근이 가능합니다.

## 참고 자료

[MDN - Set-Cookie Attributes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)

## Session-based Authentication

### Session

- 서버가 Client에 유일하고 암호화된 ID를 부여

- 중요 데이터는 서버에서 관리

### Session 전달 방법

![image](https://s3.ap-northeast-2.amazonaws.com/urclass-images/_PsLhwyFA-1618305417398.png)

Session_id는 신분증과 같은 역할을한다.

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-13-05-57-image.png)

server이용자가 많으면 메모리같은 저장공간의 일정 부분을 항상 차지하고 있어 가용메모리의 공간이 줄어들어 서버의 성능이 떨어지게 된다.

session역시도 cookie를 이용하기 때문에 xss공격으로 인해 세션쿠키가 탈취되면 개인정보 탈취의 위험이 있다.

본격적으로 로그인을 통해 인증 정보가 저장되고, 인증된 사용자가 어떤 식으로 웹사이트를 이용하는지 간단하게 알아봅시다.

사용자가 웹사이트에서 아이디 및 비밀번호를 이용해서 로그인을 시도하면(그림 1), 과연 어떤 일이 벌어질까요?

사용자가 만일 정확한 아이디와 비밀번호를 입력했다면, 서버는 인증(Authentication)에 성공했다고 판단할 것입니다. 그렇다면, 다음번에 인증을 필요로 하는 작업(그림에서와 같이, 장바구니에 물품 추가)을 요청할 경우, 또 로그인 과정을 거쳐야 할까요? 아닙니다. 서버는 아이디 및 비밀번호의 해시를 이미 알고 있기 때문에, **"인증에 성공했음"을 서버가 알고 있다면, 매번 로그인할 필요가 없을 것입니다.**

> 인증에 따라 리소스의 접근 권한(Authorization)이 달라집니다

이때 서버와 클라이언트에 각각 필요한 것이 다음과 같습니다.

- 서버는 사용자가 인증에 성공했음을 알고 있어야 합니다.
- 클라이언트는 인증 성공을 증명할 수단을 갖고 있어야 합니다.

여기서 몇 가지 용어가 등장합니다.

- 사용자가 인증에 성공한 상태는 **세션**이라고 부릅니다.
  - 서버는 일종의 저장소에 세션을 저장합니다. (그림 2) 주로 in-memory(자바스크립트 객체를 생각하면 됩니다), 또는 세션 스토어(redis 등과 같은 트랜잭션이 빠른 DB)에 저장합니다.
- 세션이 만들어지면, 각 세션을 구분할 수 있는 **세션 아이디**도 만들어지는데(그림 3), 보통 클라이언트에 세션 성공을 증명할 수단으로써 세션 아이디를 전달합니다. (그림 4)

**이때 웹사이트에서 로그인을 유지하기 위한 수단으로 쿠키를 사용합니다. 쿠키에는 서버에서 발급한 세션 아이디를 저장합니다**

쿠키를 통해 유효한 세션 아이디가 서버에 전달되고, (그림 5) 세션 스토어에 해당 세션이 존재한다면 (그림 6) 서버는 해당 요청에 접근 가능하다고 판단합니다. (그림 7,8)

하지만 쿠키에 세션 아이디 정보가 없는 경우, 서버는 해당 요청이 인증되지 않았음을 알려줍니다.

### 로그아웃

그렇다면, 로그아웃은 어떻게 구현해야 할까요? 세션 아이디가 담긴 쿠키는 클라이언트에 저장되어 있으며, 서버는 세션을 저장하고 있습니다. 서버는 그저 세션 아이디로만 요청을 판단합니다.

> 주의: 쿠키는 세션 아이디, 즉 인증 성공에 대한 증명을 갖고 있으므로, 탈취될 경우 서버는 해당 요청이 인증된 사용자의 요청이라고 판단합니다.
> 이것이, 우리가 공공 PC에서 로그아웃해야 하는 이유입니다.

그러므로 로그아웃은 다음 두 가지 작업을 해야 합니다.

- 서버의 세션 정보를 삭제해야 합니다.
- 클라이언트의 쿠키를 갱신해야 합니다.

서버가 클라이언트의 쿠키를 임의로 삭제할 수는 없습니다. 대신, `set-cookie`로 세션 아이디의 키값을 무효한 값으로 갱신해야 합니다.

## express-session

이런 세션을 대신 관리해 주는 'express-session' 이라는 모듈이 존재합니다.

다만 코딩을 바로 시도하기보다 아래 설명을 참고하여 모듈의 역할 및 사용법을 공부해 보세요.

'express-session'은 세션을 위한 미들웨어로, 'Express'에서 세션을 다룰 수 있는 공간을 보다 쉽게 만들어줍니다.

또한 필요한 경우 세션 아이디를 쿠키에 저장하고, 해당 세션 아이디에 종속되는 고유한 세션 객체를 서버 메모리에 저장합니다.
이때 세션 객체는 서로 독립적인 객체이므로 각각 다른 데이터를 저장할 수 있습니다.

req.session이 바로 세션 객체이며 req.session은 세션 객체에 세션 데이터를 저장하거나 불러오기 위해 사용합니다.

이 세션 객체에 값을 담거나, 값을 불러오는 법, 세션을 파괴하는 법은 다음 문서를 참고하세요. [GitHub: express-session](https://github.com/expressjs/session#reqsession)

![](/Users/yugeonpyo/Library/Application%20Support/marktext/images/2021-12-27-17-07-16-image.png)

### CSRF

해커들의 여러가지 공격들

- SQL injection

- XSS

- **CSRF**(Cross Site Request Forgery)

#### CSRF란
