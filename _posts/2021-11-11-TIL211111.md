---
title: 11.11 THU
---

스택(stack) - 데이터를 순서대로 쌓는 자료구조

LIFO(Last In First Out) || FILO ( First In Last Out)



1. 1차원 배열
2. 리스트

스택의 주요 기능

push - 스택공간에 데이터를 저장하는 명령어

pop - 스택공간의 최상단(Last)에 위치한 데이터를 꺼내는 명령어

top/peek - 제일 최근에 들어간 데이터, 최상위(Last) 데이터



ex) 앞으로가기, 뒤로가기, 실행취소, 계산기 등 





큐(queue) - 줄서서 기다리다, 대기행렬 구조

FIFO(First In First Out) || LILO(Last In Last Out)

ex)인쇄

속도의 차이나 시간의 차이를 극복하기위한 임시기억장치의 자료구조

이것을 통틀어 버퍼(buffer)라고 한다.



영상을 재생하기 위해 Queue에 모아두었다가 재생하기에 충분하기 모이면 재생한다.



정적인 어레이(Fixed Array)

장점 - 구현이 쉽다

단점 - 고정된 Queue 크기

동적인 어레이(Linked List)

장점 - 자유로운 Queue 크기

단점 - 구현이 어렵다

대표적 함수

Enqueue : Queue에 값을 집어넣는다

Dequeue : Queue에서 값을 빼내온다

Size : Queue의 크기를 확인

Empty : 큐가 비었는지 확인



|      |      |      |      |
| ---- | ---- | ---- | ---- |
|      |      |      |      |

우선순위큐(Priority Queue) - 가장 우선순위가 높은 데이터

값에 우선순위를 매겨서 Enqueue되는 순간 재배치가 되어 





그래프(Graph)

간선이 존재하는데 연결이 되어있다만 확인이 되고, 가중치(연결의 강도)가 얼마나 되는지 모르는 그래프는 비가중치 그래프라고한다.

정점(vertext) : 노드(node)라고도 하며, 저장되는 그래프의 기본 원소

간선(edge): 정점 간의 관계 ( 정점간의 선)

인접정점(adjacent vertex): 하나의 정점에서 간선에 의해 직접 연결되어 있는 정점

가중치그래프(weighted Graph): 연결의 강도가 적혀 있는 그래프(추가정보)

비가중치 그래프(unweighted Graph): 연결의 강도가 안적힌 그래프

무(방)향 그래프(undirected graph): 가고싶을때 가고, 오고싶을 때 올수 있는 그래프

진입차수(in-degree) / 진출차수(out-degree): 한 정점에 진입하고 진출하는 간선의 갯수

인접(adjacenct) : 두 정점 간에 간선이 직접 이어져 있는경우

자기루프(self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우(다른정점을 거치지 않음)

사이클(cycle): 한 정점에서 출발하여 해당 정점으로 돌아갈 수 있는 경우에 사이클이 존재한다.



인접행렬

| from\to | A    | B    | C    |
| ------- | ---- | ---- | ---- |
| A       | 0    | 1    | 1    |
| B       | 1    | 0    | 0    |
| C       | 1    | 0    | 0    |

A -> B, C  `[0][2], [0][3]`

B -> A

C -> A

- 우선 순위를 다뤄야 한다면 더 적합한 자료구조(ex. queue, heap)를 사용하는 것이 합리적입니다. 따라서 **보통은** 중요하지 않습니다. (*언제나 예외는 있습니다.*)



인접리스트는 왜 사용할까?

메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용합니다.

- 인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지합니다.







트리(Tree)

트리 구조는 **루트(Root)** 라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결합니다. 각 데이터를 **노드(Node)**라고 하며, 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 가집니다. 위 그림에서 A는 B와 C의 **부모 노드(Parent Node)**이고, B와 C는 A의 **자식 노드(Child Node)**입니다. 자식이 없는 노드는 나무의 잎과 같다고 하여 **리프 노드(Leaf Node)**라고 부릅니다. **형제노드(Sibling Node)**

- 노드(Node) : 트리 구조를 이루는 모든 개별 데이터
- 루트(Root) : 트리 구조의 시작점이 되는 노드
- 부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
- 자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
- 리프(Leaf) : 트리 구조의 끝 지점이고, 자식 노드가 없는 노드

바이너리트리

자식노드가 최대 2개인 노드들로 구성된 트리





* 배열 추가하는법

```js
let newArr = new Array(원하는길이)

let arr = new Array(2) // [비어있음, 비어있음]
let arr1 = new Array(3).fill(1) // [1, 1, 1]
let arr2 = new Array(5).fill(3) // [3, 3, 3]
arr[0] = 3 // arr == [3, 비어있음]

```



Array 클래스에 있는 메소드를 사용하려고 하는데,

Array안에 Array 라는 메소드가 또 있다.(재귀를 통해서 있는것 같은데)

Array(property) -> property가 뭘로 설정이 되어있는지,

Array(property).

